"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encrypt = void 0;
const Helpers_1 = require("../Helpers");
const big_integer_1 = __importDefault(require("big-integer"));
const PUBLIC_KEYS = [
    {
        fingerprint: [
            40, 85, 94, 156, 117, 240, 61, 22, 65, 244, 169, 2, 33, 107, 232,
            108, 2, 43, 180, 195,
        ],
        n: big_integer_1.default("24403446649145068056824081744112065346446136066297307473868293895086332508101251964919587745984311372853053253457835208829824428441874946556659953519213382748319518214765985662663680818277989736779506318868003755216402538945900388706898101286548187286716959100102939636333452457308619454821845196109544157601096359148241435922125602449263164512290854366930013825808102403072317738266383237191313714482187326643144603633877219028262697593882410403273959074350849923041765639673335775605842311578109726403165298875058941765362622936097839775380070572921007586266115476975819175319995527916042178582540628652481530373407"),
        e: 65537,
    },
    {
        fingerprint: [
            140, 171, 9, 34, 146, 246, 166, 50, 10, 170, 229, 247, 155, 114, 28,
            177, 29, 106, 153, 154,
        ],
        n: big_integer_1.default("25081407810410225030931722734886059247598515157516470397242545867550116598436968553551465554653745201634977779380884774534457386795922003815072071558370597290368737862981871277312823942822144802509055492512145589734772907225259038113414940384446493111736999668652848440655603157665903721517224934142301456312994547591626081517162758808439979745328030376796953660042629868902013177751703385501412640560275067171555763725421377065095231095517201241069856888933358280729674273422117201596511978645878544308102076746465468955910659145532699238576978901011112475698963666091510778777356966351191806495199073754705289253783"),
        e: 65537,
    },
    {
        fingerprint: [
            243, 218, 109, 239, 16, 202, 176, 78, 167, 8, 255, 209, 120, 234,
            205, 112, 111, 42, 91, 176,
        ],
        n: big_integer_1.default("22347337644621997830323797217583448833849627595286505527328214795712874535417149457567295215523199212899872122674023936713124024124676488204889357563104452250187725437815819680799441376434162907889288526863223004380906766451781702435861040049293189979755757428366240570457372226323943522935844086838355728767565415115131238950994049041950699006558441163206523696546297006014416576123345545601004508537089192869558480948139679182328810531942418921113328804749485349441503927570568778905918696883174575510385552845625481490900659718413892216221539684717773483326240872061786759868040623935592404144262688161923519030977"),
        e: 65537,
    },
    {
        fingerprint: [
            128, 80, 214, 72, 77, 244, 98, 7, 201, 250, 37, 244, 227, 51, 96,
            199, 182, 37, 224, 113,
        ],
        n: big_integer_1.default("24573455207957565047870011785254215390918912369814947541785386299516827003508659346069416840622922416779652050319196701077275060353178142796963682024347858398319926119639265555410256455471016400261630917813337515247954638555325280392998950756512879748873422896798579889820248358636937659872379948616822902110696986481638776226860777480684653756042166610633513404129518040549077551227082262066602286208338952016035637334787564972991208252928951876463555456715923743181359826124083963758009484867346318483872552977652588089928761806897223231500970500186019991032176060579816348322451864584743414550721639495547636008351"),
        e: 65537,
    },
];
const _serverKeys = new Map();
PUBLIC_KEYS.forEach((_a) => {
    var { fingerprint } = _a, keyInfo = __rest(_a, ["fingerprint"]);
    _serverKeys.set(Helpers_1.readBigIntFromBuffer(Buffer.from(fingerprint.slice(-8)), true, true).toString(), keyInfo);
});
/**
 * Encrypts the given data known the fingerprint to be used
 * in the way Telegram requires us to do so (sha1(data) + data + padding)

 * @param fingerprint the fingerprint of the RSA key.
 * @param data the data to be encrypted.
 * @returns {Buffer|*|undefined} the cipher text, or undefined if no key matching this fingerprint is found.
 */
function encrypt(fingerprint, data) {
    return __awaiter(this, void 0, void 0, function* () {
        const key = _serverKeys.get(fingerprint.toString());
        if (!key) {
            return undefined;
        }
        // len(sha1.digest) is always 20, so we're left with 255 - 20 - x padding
        const rand = Helpers_1.generateRandomBytes(235 - data.length);
        const toEncrypt = Buffer.concat([yield Helpers_1.sha1(data), data, rand]);
        // rsa module rsa.encrypt adds 11 bits for padding which we don't want
        // rsa module uses rsa.transform.bytes2int(to_encrypt), easier way:
        const payload = Helpers_1.readBigIntFromBuffer(toEncrypt, false);
        const encrypted = Helpers_1.modExp(payload, big_integer_1.default(key.e), key.n);
        // rsa module uses transform.int2bytes(encrypted, keylength), easier:
        return Helpers_1.readBufferFromBigInt(encrypted, 256, false);
    });
}
exports.encrypt = encrypt;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUlNBLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vZ3JhbWpzL2NyeXB0by9SU0EudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx3Q0FNb0I7QUFDcEIsOERBQWlDO0FBRWpDLE1BQU0sV0FBVyxHQUFHO0lBQ2hCO1FBQ0ksV0FBVyxFQUFFO1lBQ1QsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHO1lBQ2hFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHO1NBQ3ZCO1FBQ0QsQ0FBQyxFQUFFLHFCQUFNLENBQ0wsMm1CQUEybUIsQ0FDOW1CO1FBQ0QsQ0FBQyxFQUFFLEtBQUs7S0FDWDtJQUNEO1FBQ0ksV0FBVyxFQUFFO1lBQ1QsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFO1lBQ25FLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHO1NBQ3pCO1FBQ0QsQ0FBQyxFQUFFLHFCQUFNLENBQ0wsMm1CQUEybUIsQ0FDOW1CO1FBQ0QsQ0FBQyxFQUFFLEtBQUs7S0FDWDtJQUNEO1FBQ0ksV0FBVyxFQUFFO1lBQ1QsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUc7WUFDaEUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHO1NBQzdCO1FBQ0QsQ0FBQyxFQUFFLHFCQUFNLENBQ0wsMm1CQUEybUIsQ0FDOW1CO1FBQ0QsQ0FBQyxFQUFFLEtBQUs7S0FDWDtJQUNEO1FBQ0ksV0FBVyxFQUFFO1lBQ1QsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFO1lBQ2hFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHO1NBQ3pCO1FBQ0QsQ0FBQyxFQUFFLHFCQUFNLENBQ0wsMm1CQUEybUIsQ0FDOW1CO1FBQ0QsQ0FBQyxFQUFFLEtBQUs7S0FDWDtDQUNKLENBQUM7QUFFRixNQUFNLFdBQVcsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBRTlCLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUEyQixFQUFFLEVBQUU7UUFBL0IsRUFBRSxXQUFXLE9BQWMsRUFBVCxPQUFPLGNBQXpCLGVBQTJCLENBQUY7SUFDMUMsV0FBVyxDQUFDLEdBQUcsQ0FDWCw4QkFBb0IsQ0FDaEIsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFDbEMsSUFBSSxFQUNKLElBQUksQ0FDUCxDQUFDLFFBQVEsRUFBRSxFQUNaLE9BQU8sQ0FDVixDQUFDO0FBQ04sQ0FBQyxDQUFDLENBQUM7QUFFSDs7Ozs7OztHQU9HO0FBQ0gsU0FBc0IsT0FBTyxDQUFDLFdBQThCLEVBQUUsSUFBWTs7UUFDdEUsTUFBTSxHQUFHLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUNwRCxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ04sT0FBTyxTQUFTLENBQUM7U0FDcEI7UUFFRCx5RUFBeUU7UUFDekUsTUFBTSxJQUFJLEdBQUcsNkJBQW1CLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVwRCxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxjQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFaEUsc0VBQXNFO1FBQ3RFLG1FQUFtRTtRQUNuRSxNQUFNLE9BQU8sR0FBRyw4QkFBb0IsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDdkQsTUFBTSxTQUFTLEdBQUcsZ0JBQU0sQ0FBQyxPQUFPLEVBQUUscUJBQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hELHFFQUFxRTtRQUNyRSxPQUFPLDhCQUFvQixDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdkQsQ0FBQztDQUFBO0FBakJELDBCQWlCQyJ9