"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MTProtoPlainSender = void 0;
/**
 *  This module contains the class used to communicate with Telegram's servers
 *  in plain text, when no authorization key has been created yet.
 */
const MTProtoState_1 = require("./MTProtoState");
const Helpers_1 = require("../Helpers");
const errors_1 = require("../errors");
const extensions_1 = require("../extensions");
/**
 * MTProto Mobile Protocol plain sender (https://core.telegram.org/mtproto/description#unencrypted-messages)
 */
class MTProtoPlainSender {
    /**
     * Initializes the MTProto plain sender.
     * @param connection connection: the Connection to be used.
     * @param loggers
     */
    constructor(connection, loggers) {
        this._state = new MTProtoState_1.MTProtoState(undefined, loggers);
        this._connection = connection;
    }
    /**
     * Sends and receives the result for the given request.
     * @param request
     */
    send(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let body = request.getBytes();
            let msgId = this._state._getNewMsgId();
            const m = Helpers_1.toSignedLittleBuffer(msgId, 8);
            const b = Buffer.alloc(4);
            b.writeInt32LE(body.length, 0);
            const res = Buffer.concat([
                Buffer.concat([Buffer.alloc(8), m, b]),
                body,
            ]);
            yield this._connection.send(res);
            body = yield this._connection.recv();
            if (body.length < 8) {
                throw new errors_1.InvalidBufferError(body);
            }
            const reader = new extensions_1.BinaryReader(body);
            const authKeyId = reader.readLong();
            if (authKeyId.neq(BigInt(0))) {
                throw new Error("Bad authKeyId");
            }
            msgId = reader.readLong();
            if (msgId.eq(BigInt(0))) {
                throw new Error("Bad msgId");
            }
            /** ^ We should make sure that the read ``msg_id`` is greater
             * than our own ``msg_id``. However, under some circumstances
             * (bad system clock/working behind proxies) this seems to not
             * be the case, which would cause endless assertion errors.
             */
            const length = reader.readInt();
            if (length <= 0) {
                throw new Error("Bad length");
            }
            /**
             * We could read length bytes and use those in a new reader to read
             * the next TLObject without including the padding, but since the
             * reader isn't used for anything else after this, it's unnecessary.
             */
            return reader.tgReadObject();
        });
    }
}
exports.MTProtoPlainSender = MTProtoPlainSender;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTVRQcm90b1BsYWluU2VuZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vZ3JhbWpzL25ldHdvcmsvTVRQcm90b1BsYWluU2VuZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7R0FHRztBQUNILGlEQUE4QztBQUU5Qyx3Q0FBa0Q7QUFDbEQsc0NBQStDO0FBQy9DLDhDQUE2QztBQUc3Qzs7R0FFRztBQUVILE1BQWEsa0JBQWtCO0lBSTNCOzs7O09BSUc7SUFDSCxZQUFZLFVBQWUsRUFBRSxPQUFZO1FBQ3JDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSwyQkFBWSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNuRCxJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0csSUFBSSxDQUFDLE9BQXVCOztZQUM5QixJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7WUFFOUIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUN2QyxNQUFNLENBQUMsR0FBRyw4QkFBb0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDekMsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMxQixDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFL0IsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztnQkFDdEIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUN0QyxJQUFJO2FBQ1AsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQyxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3JDLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ2pCLE1BQU0sSUFBSSwyQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN0QztZQUNELE1BQU0sTUFBTSxHQUFHLElBQUkseUJBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN0QyxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDcEMsSUFBSSxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO2FBQ3BDO1lBQ0QsS0FBSyxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUMxQixJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDaEM7WUFDRDs7OztlQUlHO1lBRUgsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2hDLElBQUksTUFBTSxJQUFJLENBQUMsRUFBRTtnQkFDYixNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQ2pDO1lBQ0Q7Ozs7ZUFJRztZQUNILE9BQU8sTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ2pDLENBQUM7S0FBQTtDQUNKO0FBN0RELGdEQTZEQyJ9