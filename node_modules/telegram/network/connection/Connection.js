"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObfuscatedConnection = exports.PacketCodec = exports.Connection = void 0;
const extensions_1 = require("../../extensions");
const extensions_2 = require("../../extensions");
const Helpers_1 = require("../../Helpers");
/**
 * The `Connection` class is a wrapper around ``asyncio.open_connection``.
 *
 * Subclasses will implement different transport modes as atomic operations,
 * which this class eases doing since the exposed interface simply puts and
 * gets complete data payloads to and from queues.
 *
 * The only error that will raise from send and receive methods is
 * ``ConnectionError``, which will raise when attempting to send if
 * the client is disconnected (includes remote disconnections).
 */
class Connection {
    constructor(ip, port, dcId, loggers) {
        this._ip = ip;
        this._port = port;
        this._dcId = dcId;
        this._log = loggers;
        this._connected = false;
        this._sendTask = undefined;
        this._recvTask = undefined;
        this._codec = undefined;
        this._obfuscation = undefined; // TcpObfuscated and MTProxy
        this._sendArray = new extensions_2.AsyncQueue();
        this._recvArray = new extensions_2.AsyncQueue();
        this.socket = Helpers_1.IS_NODE
            ? new extensions_1.PromisedNetSockets()
            : new extensions_1.PromisedWebSockets();
        //this.socket = new PromisedWebSockets()
    }
    _connect() {
        return __awaiter(this, void 0, void 0, function* () {
            this._log.debug("Connecting");
            this._codec = new this.PacketCodecClass(this);
            yield this.socket.connect(this._port, this._ip);
            this._log.debug("Finished connecting");
            // await this.socket.connect({host: this._ip, port: this._port});
            yield this._initConn();
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._connect();
            this._connected = true;
            this._sendTask = this._sendLoop();
            this._recvTask = this._recvLoop();
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this._connected = false;
            yield this._recvArray.push(undefined);
            yield this.socket.close();
        });
    }
    send(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._connected) {
                // this will stop the current loop
                // @ts-ignore
                yield this._sendArray(undefined);
                throw new Error("Not connected");
            }
            yield this._sendArray.push(data);
        });
    }
    recv() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this._connected) {
                const result = yield this._recvArray.pop();
                // undefined = sentinel value = keep trying
                if (result && result.length) {
                    return result;
                }
            }
            throw new Error("Not connected");
        });
    }
    _sendLoop() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO handle errors
            try {
                while (this._connected) {
                    const data = yield this._sendArray.pop();
                    if (!data) {
                        this._sendTask = undefined;
                        return;
                    }
                    yield this._send(data);
                }
            }
            catch (e) {
                this._log.info("The server closed the connection while sending");
            }
        });
    }
    _recvLoop() {
        return __awaiter(this, void 0, void 0, function* () {
            let data;
            while (this._connected) {
                try {
                    data = yield this._recv();
                    if (!data) {
                        throw new Error("no data received");
                    }
                }
                catch (e) {
                    this._log.info("connection closed");
                    //await this._recvArray.push()
                    this.disconnect();
                    return;
                }
                yield this._recvArray.push(data);
            }
        });
    }
    _initConn() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._codec.tag) {
                yield this.socket.write(this._codec.tag);
            }
        });
    }
    _send(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const encodedPacket = this._codec.encodePacket(data);
            this.socket.write(encodedPacket);
        });
    }
    _recv() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._codec.readPacket(this.socket);
        });
    }
    toString() {
        return `${this._ip}:${this._port}/${this.constructor.name.replace("Connection", "")}`;
    }
}
exports.Connection = Connection;
class ObfuscatedConnection extends Connection {
    constructor() {
        super(...arguments);
        this.ObfuscatedIO = undefined;
    }
    _initConn() {
        return __awaiter(this, void 0, void 0, function* () {
            this._obfuscation = new this.ObfuscatedIO(this);
            this.socket.write(this._obfuscation.header);
        });
    }
    _send(data) {
        return __awaiter(this, void 0, void 0, function* () {
            this._obfuscation.write(this._codec.encodePacket(data));
        });
    }
    _recv() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._codec.readPacket(this._obfuscation);
        });
    }
}
exports.ObfuscatedConnection = ObfuscatedConnection;
class PacketCodec {
    constructor(connection) {
        this._conn = connection;
    }
    encodePacket(data) {
        throw new Error("Not Implemented");
        // Override
    }
    readPacket(reader) {
        return __awaiter(this, void 0, void 0, function* () {
            // override
            throw new Error("Not Implemented");
        });
    }
}
exports.PacketCodec = PacketCodec;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29ubmVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2dyYW1qcy9uZXR3b3JrL2Nvbm5lY3Rpb24vQ29ubmVjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxpREFBMEU7QUFDMUUsaURBQThDO0FBQzlDLDJDQUF3QztBQUV4Qzs7Ozs7Ozs7OztHQVVHO0FBQ0gsTUFBTSxVQUFVO0lBZ0JaLFlBQVksRUFBVSxFQUFFLElBQVksRUFBRSxJQUFZLEVBQUUsT0FBWTtRQUM1RCxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQztRQUNkLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1FBQzNCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1FBQzNCLElBQUksQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxZQUFZLEdBQUcsU0FBUyxDQUFDLENBQUMsNEJBQTRCO1FBQzNELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSx1QkFBVSxFQUFFLENBQUM7UUFDbkMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLHVCQUFVLEVBQUUsQ0FBQztRQUNuQyxJQUFJLENBQUMsTUFBTSxHQUFHLGlCQUFPO1lBQ2pCLENBQUMsQ0FBQyxJQUFJLCtCQUFrQixFQUFFO1lBQzFCLENBQUMsQ0FBQyxJQUFJLCtCQUFrQixFQUFFLENBQUM7UUFFL0Isd0NBQXdDO0lBQzVDLENBQUM7SUFFSyxRQUFROztZQUNWLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQzlCLElBQUksQ0FB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