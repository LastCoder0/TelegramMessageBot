"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const bigInt = require("big-integer");
const { generateRandomBytes, readBigIntFromBuffer, isArrayLike, } = require("../Helpers");
function generateRandomBigInt() {
    return readBigIntFromBuffer(generateRandomBytes(8), false, true);
}
const { parseTl, serializeBytes, serializeDate, } = require("./generationHelpers");
const { IS_NODE, toSignedLittleBuffer } = require("../Helpers");
let tlContent, schemeContent;
if (IS_NODE) {
    const fs = require("fs");
    tlContent = fs.readFileSync(__dirname + "/static/api.tl", "utf-8");
    schemeContent = fs.readFileSync(__dirname + "/static/schema.tl", "utf-8");
}
else {
    tlContent = require("!!raw-loader!./static/api.tl").default;
    schemeContent = require("!!raw-loader!./static/schema.tl").default;
}
const NAMED_AUTO_CASTS = new Set(["chatId,int"]);
const NAMED_BLACKLIST = new Set(["discardEncryption"]);
const AUTO_CASTS = new Set([
    "InputPeer",
    "InputChannel",
    "InputUser",
    "InputDialogPeer",
    "InputNotifyPeer",
    "InputMedia",
    "InputPhoto",
    "InputMessage",
    "InputDocument",
    "InputChatPhoto",
]);
class CastError extends Error {
    constructor(objectName, expected, actual, ...params) {
        // Pass remaining arguments (including vendor specific ones) to parent constructor
        const message = "Found wrong type for " +
            objectName +
            ". expected " +
            expected +
            " but received " +
            actual +
            ".If you think this is a mistake please report it.";
        super(message, ...params);
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, CastError);
        }
        this.name = "CastError";
        // Custom debugging information
    }
}
const CACHING_SUPPORTED = typeof self !== "undefined" && self.localStorage !== undefined;
const CACHE_KEY = "GramJs:apiCache";
function buildApiFromTlSchema() {
    let definitions;
    const fromCache = CACHING_SUPPORTED && loadFromCache();
    if (fromCache) {
        definitions = fromCache;
    }
    else {
        definitions = loadFromTlSchemas();
        if (CACHING_SUPPORTED) {
            localStorage.setItem(CACHE_KEY, JSON.stringify(definitions));
        }
    }
    return createClasses("all", definitions);
}
function loadFromCache() {
    const jsonCache = localStorage.getItem(CACHE_KEY);
    return jsonCache && JSON.parse(jsonCache);
}
function loadFromTlSchemas() {
    const [constructorParamsApi, functionParamsApi] = extractParams(tlContent);
    const [constructorParamsSchema, functionParamsSchema] = extractParams(schemeContent);
    const constructors = [].concat(constructorParamsApi, constructorParamsSchema);
    const requests = [].concat(functionParamsApi, functionParamsSchema);
    return [].concat(constructors, requests);
}
function extractParams(fileContent) {
    const f = parseTl(fileContent, 109);
    const constructors = [];
    const functions = [];
    for (const d of f) {
        d.isFunction ? functions.push(d) : constructors.push(d);
    }
    return [constructors, functions];
}
function argToBytes(x, type, argName, requestName) {
    switch (type) {
        case "int":
            const i = Buffer.alloc(4);
            i.writeInt32LE(x, 0);
            return i;
        case "long":
            return toSignedLittleBuffer(x, 8);
        case "int128":
            return toSignedLittleBuffer(x, 16);
        case "int256":
            return toSignedLittleBuffer(x, 32);
        case "double":
            const d = Buffer.alloc(8);
            d.writeDoubleLE(x, 0);
            return d;
        case "string":
            return serializeBytes(x);
        case "Bool":
            return x
                ? Buffer.from("b5757299", "hex")
                : Buffer.from("379779bc", "hex");
        case "true":
            return Buffer.alloc(0);
        case "bytes":
            return serializeBytes(x);
        case "date":
            return serializeDate(x);
        default:
            if (x === undefined || typeof x.getBytes !== "function") {
                throw new Error(`Required object ${argName} of ${requestName} is undefined`);
            }
            return x.getBytes();
    }
}
function getInputFromResolve(utils, client, peer, peerType) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (peerType) {
            case "InputPeer":
                return utils.getInputPeer(yield client.getInputEntity(peer));
            case "InputChannel":
                return utils.getInputChannel(yield client.getInputEntity(peer));
            case "InputUser":
                return utils.getInputUser(yield client.getInputEntity(peer));
            case "InputDialogPeer":
                return yield client._getInputDialog(peer);
            case "InputNotifyPeer":
                return yield client._getInputNotify(peer);
            case "InputMedia":
                return utils.getInputMedia(peer);
            case "InputPhoto":
                return utils.getInputPhoto(peer);
            case "InputMessage":
                return utils.getInputMessage(peer);
            case "InputDocument":
                return utils.getInputDocument(peer);
            case "InputChatPhoto":
                return utils.getInputChatPhoto(peer);
            case "chatId,int":
                return yield client.getPeerId(peer, false);
            default:
                throw new Error("unsupported peer type : " + peerType);
        }
    });
}
function getArgFromReader(reader, arg) {
    if (arg.isVector) {
        if (arg.useVectorId) {
            reader.readInt();
        }
        const temp = [];
        const len = reader.readInt();
        arg.isVector = false;
        for (let i = 0; i < len; i++) {
            temp.push(getArgFromReader(reader, arg));
        }
        arg.isVector = true;
        return temp;
    }
    else if (arg.flagIndicator) {
        return reader.readInt();
    }
    else {
        switch (arg.type) {
            case "int":
                return reader.readInt();
            case "long":
                return reader.readLong();
            case "int128":
                return reader.readLargeInt(128);
            case "int256":
                return reader.readLargeInt(256);
            case "double":
                return reader.readDouble();
            case "string":
                return reader.tgReadString();
            case "Bool":
                return reader.tgReadBool();
            case "true":
                return true;
            case "bytes":
                return reader.tgReadBytes();
            case "date":
                return reader.tgReadDate();
            default:
                if (!arg.skipConstructorId) {
                    return reader.tgReadObject();
                }
                else {
                    return api.constructors[arg.type].fromReader(reader);
                }
        }
    }
}
function compareType(value, type) {
    let correct = true;
    switch (type) {
        case "number":
            correct = typeof value === "number" || value === undefined;
            break;
        case "string":
        case "boolean":
            correct = typeof value === type;
            break;
        case "bigInt":
            correct =
                bigInt.isInstance(value) ||
                    typeof value === "bigint" ||
                    value === undefined;
            break;
        case "true":
            // true value is always correct
            break;
        case "buffer":
            correct = Buffer.isBuffer(value);
            break;
        case "date":
            correct =
                (value &&
                    Object.prototype.toString.call(value) === "[object Date]" &&
                    !isNaN(value)) ||
                    typeof value === "number";
            break;
        default:
            console.error(new Error("Unknown type." + type));
    }
    return correct;
}
function createClasses(classesType, params) {
    const classes = {};
    for (const classParams of params) {
        const { name, constructorId, subclassOfId, argsConfig, namespace, isFunction, result, } = classParams;
        const fullName = [namespace, name].join(".").replace(/^\./, "");
        class VirtualClass {
            constructor(args) {
                this.CONSTRUCTOR_ID = constructorId;
                this.SUBCLASS_OF_ID = subclassOfId;
                this.className = fullName;
                this.classType = isFunction ? "request" : "constructor";
                args = args || {};
                for (const argName in argsConfig) {
                    if (argName === "randomId" && !args[argName]) {
                        if (argsConfig[argName].isVector) {
                            const rands = [];
                            for (let i = 0; i < args["id"].length; i++) {
                                rands.push(generateRandomBigInt());
                            }
                            this[argName] = rands;
                        }
                        else {
                            this[argName] = generateRandomBigInt();
                        }
                    }
                    else {
                        this[argName] = args[argName];
                    }
                }
            }
            static fromReader(reader) {
                const args = {};
                for (const argName in argsConfig) {
                    if (argsConfig.hasOwnProperty(argName)) {
                        const arg = argsConfig[argName];
                        if (arg.isFlag) {
                            if (arg.type === "true") {
                                args[argName] = Boolean(args["flags"] & (1 << arg.flagIndex));
                                continue;
                            }
                            if (args["flags"] & (1 << arg.flagIndex)) {
                                args[argName] = getArgFromReader(reader, arg);
                            }
                            else {
                                args[argName] = null;
                            }
                        }
                        else {
                            if (arg.flagIndicator) {
                                arg.name = "flags";
                            }
                            args[argName] = getArgFromReader(reader, arg);
                        }
                    }
                }
                return new this(args);
            }
            validate() {
                for (const arg in argsConfig) {
                    if (argsConfig.hasOwnProperty(arg)) {
                        if (arg === "flags" || argsConfig[arg].isFlag) {
                            // we don't care about flags
                            continue;
                        }
                        const currentValue = this[arg];
                        this.assertType(arg, argsConfig[arg], currentValue);
                    }
                }
            }
            assertType(objectName, object, value) {
                let expected;
                if (object["isVector"]) {
                    if (!isArrayLike(value)) {
                        console.error(new CastError(objectName, "array", value));
                    }
                    if (value == undefined) {
                        value = [];
                    }
                    for (const o of value) {
                        this.assertType(objectName, Object.assign(Object.assign({}, object), { isVector: false }), o);
                    }
                }
                else {
                    switch (object["type"]) {
                        case "int":
                            expected = "number";
                            break;
                        case "long":
                        case "int128":
                        case "int256":
                        case "double":
                            expected = "bigInt";
                            break;
                        case "string":
                            expected = "string";
                            break;
                        case "Bool":
                            expected = "boolean";
                            break;
                        case "true":
                            expected = "true";
                            break;
                        case "bytes":
                            expected = "buffer";
                            break;
                        case "date":
                            expected = "date";
                            break;
                        default:
                            expected = "object";
                    }
                    if (expected === "object") {
                        // will be validated in get byte();
                    }
                    else {
                        const isCorrectType = compareType(value, expected);
                        if (isCorrectType !== true) {
                            console.error(new CastError(objectName, expected, value));
                        }
                    }
                }
            }
            getBytes() {
                try {
                    this.validate();
                }
                catch (e) {
                    // feature still in alpha so errors are expected.
                }
                const idForBytes = this.CONSTRUCTOR_ID;
                const c = Buffer.alloc(4);
                c.writeUInt32LE(idForBytes, 0);
                const buffers = [c];
                for (const arg in argsConfig) {
                    if (argsConfig.hasOwnProperty(arg)) {
                        if (argsConfig[arg].isFlag) {
                            if (this[arg] === false ||
                                this[arg] === null ||
                                this[arg] === undefined ||
                                argsConfig[arg].type === "true") {
                                continue;
                            }
                        }
                        if (argsConfig[arg].isVector) {
                            if (argsConfig[arg].useVectorId) {
                                buffers.push(Buffer.from("15c4b51c", "hex"));
                            }
                            const l = Buffer.alloc(4);
                            l.writeInt32LE(this[arg].length, 0);
                            buffers.push(l, Buffer.concat(this[arg].map((x) => argToBytes(x, argsConfig[arg].type, fullName))));
                        }
                        else if (argsConfig[arg].flagIndicator) {
                            if (!Object.values(argsConfig).some((f) => f.isFlag)) {
                                buffers.push(Buffer.alloc(4));
                            }
                            else {
                                let flagCalculate = 0;
                                for (const f in argsConfig) {
                                    if (argsConfig[f].isFlag) {
                                        if (this[f] === false ||
                                            this[f] === undefined ||
                                            this[f] === null) {
                                            flagCalculate |= 0;
                                        }
                                        else {
                                            flagCalculate |=
                                                1 << argsConfig[f].flagIndex;
                                        }
                                    }
                                }
                                const f = Buffer.alloc(4);
                                f.writeUInt32LE(flagCalculate, 0);
                                buffers.push(f);
                            }
                        }
                        else {
                            buffers.push(argToBytes(this[arg], argsConfig[arg].type, arg, fullName));
                            if (this[arg] &&
                                typeof this[arg].getBytes === "function") {
                                let boxed = argsConfig[arg].type.charAt(argsConfig[arg].type.indexOf(".") + 1);
                                boxed = boxed === boxed.toUpperCase();
                                if (!boxed) {
                                    buffers.shift();
                                }
                            }
                        }
                    }
                }
                return Buffer.concat(buffers);
            }
            readResult(reader) {
                if (!isFunction) {
                    throw new Error("`readResult()` called for non-request instance");
                }
                const m = result.match(/Vector<(int|long)>/);
                if (m) {
                    reader.readInt();
                    const temp = [];
                    const len = reader.readInt();
                    if (m[1] === "int") {
                        for (let i = 0; i < len; i++) {
                            temp.push(reader.readInt());
                        }
                    }
                    else {
                        for (let i = 0; i < len; i++) {
                            temp.push(reader.readLong());
                        }
                    }
                    return temp;
                }
                else {
                    return reader.tgReadObject();
                }
            }
            resolve(client, utils) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!isFunction) {
                        throw new Error("`resolve()` called for non-request instance");
                    }
                    for (const arg in argsConfig) {
                        if (argsConfig.hasOwnProperty(arg)) {
                            if (!AUTO_CASTS.has(argsConfig[arg].type)) {
                                if (!NAMED_AUTO_CASTS.has(`${argsConfig[arg].name},${argsConfig[arg].type}`)) {
                                    continue;
                                }
                            }
                            if (argsConfig[arg].isFlag) {
                                if (!this[arg]) {
                                    continue;
                                }
                            }
                            if (argsConfig[arg].isVector) {
                                const temp = [];
                                for (const x of this[arg]) {
                                    temp.push(yield getInputFromResolve(utils, client, x, argsConfig[arg].type));
                                }
                                this[arg] = temp;
                            }
                            else {
                                this[arg] = yield getInputFromResolve(utils, client, this[arg], argsConfig[arg].type);
                            }
                        }
                    }
                });
            }
        }
        VirtualClass.CONSTRUCTOR_ID = constructorId;
        VirtualClass.SUBCLASS_OF_ID = subclassOfId;
        VirtualClass.className = fullName;
        VirtualClass.classType = isFunction ? "request" : "constructor";
        if (namespace) {
            if (!classes[namespace]) {
                classes[namespace] = {};
            }
            classes[namespace][name] = VirtualClass;
        }
        else {
            classes[name] = VirtualClass;
        }
    }
    return classes;
}
const api = buildApiFromTlSchema();
module.exports = { Api: api };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vZ3JhbWpzL3RsL2FwaS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBRXRDLE1BQU0sRUFDRixtQkFBbUIsRUFDbkIsb0JBQW9CLEVBQ3BCLFdBQVcsR0FDZCxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUUxQixTQUFTLG9CQUFvQjtJQUN6QixPQUFPLG9CQUFvQixDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNyRSxDQUFDO0FBRUQsTUFBTSxFQUNGLE9BQU8sRUFDUCxjQUFjLEVBQ2QsYUFBYSxHQUNoQixHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQ25DLE1BQU0sRUFBRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDaEUsSUFBSSxTQUFTLEVBQUUsYUFBYSxDQUFDO0FBQzdCLElBQUksT0FBTyxFQUFFO0lBQ1QsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXpCLFNBQVMsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNuRSxhQUFhLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLEVBQUUsT0FBTyxDQUFDLENBQUM7Q0FDN0U7S0FBTTtJQUNILFNBQVMsR0FBRyxPQUFPLENBQUMsOEJBQThCLENBQUMsQ0FBQyxPQUFPLENBQUM7SUFDNUQsYUFBYSxHQUFHLE9BQU8sQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztDQUN0RTtBQUNELE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxZ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